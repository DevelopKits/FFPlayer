// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under project/java dir
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.ffmpeg.ffplayer.render;

import org.ffmpeg.ffplayer.config.Settings;
import org.ffmpeg.ffplayer.render.SDLInput.DifferentTouchInput;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.CursorLoader;
import android.database.Cursor;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.net.Uri;
import android.provider.MediaStore;
import android.util.Log;
import android.view.View;
import android.widget.MediaController;
import android.widget.MediaController.MediaPlayerControl;
import java.util.Map;

/**
 * Displays a video file. The FFPlayerView class can load images from various
 * sources (such as resources or content providers), takes care of computing its
 * measurement from the video so that it can be used in any layout manager, and
 * provides various display options such as scaling and tinting.
 */

public class FFPlayerView extends GLSurfaceView_SDL implements MediaPlayerControl {
    private static final String LOG_TAG                  = "FFPlayerView";
    // all possible internal states
    private static final int    STATE_ERROR              = -1;
    private static final int    STATE_IDLE               = 0;
    private static final int    STATE_PREPARING          = 1;
    private static final int    STATE_PREPARED           = 2;
    private static final int    STATE_PLAYING            = 3;
    private static final int    STATE_PAUSED             = 4;
    private static final int    STATE_PLAYBACK_COMPLETED = 5;

    // mCurrentState is a VideoView object's current state.
    private int                 mCurrentState            = STATE_IDLE;
    DefaultRender               mRender;
    Context                     mContext;
    DifferentTouchInput         touchInput               = null;
    private MediaController     mMediaController         = null;
    private boolean hasRenderSet = false;

    public FFPlayerView(Context context, ScreenKeyboardHelper keyboardHelper, AdHelper adHelper,
            AppHelper appHelper) {
        super(context);
        mContext = context;
        touchInput = DifferentTouchInput.getInstance();
        setEGLConfigChooser(Settings.VideoDepthBpp, Settings.NeedDepthBuffer,
                Settings.NeedStencilBuffer, Settings.NeedGles2);
        mRender = new DefaultRender(context, keyboardHelper, adHelper, appHelper);
    }

    public void setMediaController(MediaController controller) {
        if (mMediaController != null) {
            mMediaController.hide();
        }
        mMediaController = controller;
        attachMediaController();
    }

    @SuppressLint("NewApi")
        private String getRealPathFromURI(Uri contentUri) {
        String[] proj = { MediaStore.Video.Media.DATA };
        CursorLoader loader = new CursorLoader(mContext, contentUri, proj, null, null, null);
        Cursor cursor = loader.loadInBackground();
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA);
        cursor.moveToFirst();
        return cursor.getString(column_index);
    }

    public void setMediaURI(Uri uri) {
        Log.d(LOG_TAG, "setMediaURI:" + uri);
        if (null == uri) {
            return;
        }

        Settings.mediaUrl = getRealPathFromURI(uri);
        Log.d(LOG_TAG, "Case 1 Settings.mediaUrl:" + Settings.mediaUrl);

        String scheme = uri.getScheme();
        if (scheme == null || scheme.equals("file")) {
            Log.d(LOG_TAG, "setMediaURI() path:" + uri.getPath());
            Settings.mediaUrl = uri.getPath();
            return;
        }
    }

    public void setMediaURI(Uri uri, Map<String, String> headers) {
        if (null == headers) {
            setMediaURI(uri);
        }
    }

    private boolean isInPlaybackState() {
        return (mCurrentState != STATE_ERROR && mCurrentState != STATE_IDLE && mCurrentState != STATE_PREPARING);
    }

    private void attachMediaController() {
        Log.d(LOG_TAG, "attachMediaController in mMediaPlayer " + mMediaController);
        if (/* mMediaPlayer != null && */mMediaController != null) {
            mMediaController.setMediaPlayer(this);
            View anchorView = this.getParent() instanceof View ? (View) this.getParent() : this;
            mMediaController.setAnchorView(anchorView);
            mMediaController.setEnabled(/* isInPlaybackState() */true);
        }
    }

    // interface MediaPlayerControl start
    public boolean canPause() {
        // TODO: refine this
        return true;
    }

    public boolean canSeekBackward() {
        // TODO: refine this
        return true;
    }

    public boolean canSeekForward() {
        // TODO: refine this
        return true;
    }

    public int getBufferPercentage() {
        // TODO: add MediaPlayer.OnBufferingUpdateListener support
        return 0;
    }

    public int getCurrentPosition() {
        int currentPosition = nativeGetCurrentPosition();
        Log.d(LOG_TAG, "CurrentPosition:" + currentPosition);
        return currentPosition;
    }

    public int getDuration() {
        int duration = nativeGetDuration();
        Log.d(LOG_TAG, "duration:" + duration);
        return duration;
    }

    public boolean isPlaying() {
        // return isInPlaybackState();
        return true;
    }

    public void start() {
        Log.d(LOG_TAG, "start() mCurrentState:" + mCurrentState);
        if (!isInPlaybackState()) {
            Log.d(LOG_TAG, "acually start");
            if (!hasRenderSet) {
                setRenderer(mRender);
                hasRenderSet = true;
            }
            Log.d(LOG_TAG, "start() inject native key KEYCODE_MEDIA_PLAY");
            nativeKey(KeyEvent.KEYCODE_MEDIA_PLAY, 1);
            nativeKey(KeyEvent.KEYCODE_MEDIA_PLAY, 0);
            mCurrentState = STATE_PLAYING;
        }
    }
    
    public void pause() {
        Log.d(LOG_TAG, "pause() mCurrentState:" + mCurrentState);
        if (isInPlaybackState()) {
            Log.d(LOG_TAG, "start() inject native key KEYCODE_MEDIA_PAUSE");
            nativeKey(KeyEvent.KEYCODE_MEDIA_PAUSE, 1);
            nativeKey(KeyEvent.KEYCODE_MEDIA_PAUSE, 0);
            mCurrentState = STATE_PAUSED;
        }
    }

    public void seekTo(int msec) {
        // TODO: implement this
        if (isInPlaybackState()) {
        } else {

            // mSeekWhenPrepared = msec;
        }
    }


    // interface MediaPlayerControl end

    @Override
    public boolean onTouchEvent(final MotionEvent event) {
        Log.d(LOG_TAG, " onTouchEvent() MotionEvent:" + event);
        if (null != mMediaController && !mMediaController.isShowing()) {
            Log.d(LOG_TAG, "onTouchEvent:" + event);
            mMediaController.show();
        }

//      touchInput.process(event);
//      if (DefaultRender.mRatelimitTouchEvents) {
//          limitEventRate(event);
//      }
        return true;
    };

    @Override
    public boolean onGenericMotionEvent(final MotionEvent event) {
        touchInput.processGenericEvent(event);
        if (DefaultRender.mRatelimitTouchEvents) {
            limitEventRate(event);
        }
        return true;
    }

    public void limitEventRate(final MotionEvent event) {
        // Wait a bit, and try to synchronize to app framerate, or event thread
        // will eat all CPU and we'll lose FPS
        // With Froyo the rate of touch events seems to be limited by OS, but
        // they are arriving faster then we're redrawing anyway
        if ((event.getAction() == MotionEvent.ACTION_MOVE || event.getAction() == MotionEvent.ACTION_HOVER_MOVE)) {
            synchronized (mRender) {
                try {
                    mRender.wait(300L); // And sometimes the app decides not
                                          // to render at all, so this timeout
                                          // should not be big.
                } catch (InterruptedException e) {
                }
            }
        }
    }

    public void onDestroy() {
        if (null != mRender) {
            ((DefaultRender) mRender).onDestroy();
        }
    };

    @Override
    public void onPause() {
        if (mRender.getState() == GLSurfaceView_SDL.Renderer.STATE_PAUSED)
            return;
        mRender.setState(GLSurfaceView_SDL.Renderer.STATE_PAUSED);
        ((DefaultRender) mRender).nativeGlContextLostAsyncEvent();
        if (mRender.accelerometer != null) // For some reason it crashes here
                                             // often - are we getting this
                                             // event before initialization?
            mRender.accelerometer.stop();
        super.onPause();
    };

    public boolean isPaused() {
        return mRender.mPaused;
    }

    @Override
    public void onResume() {
        if (mRender.getState() != GLSurfaceView_SDL.Renderer.STATE_PAUSED)
            return;
        mRender.setState(GLSurfaceView_SDL.Renderer.STATE_ACTIVE);
        super.onResume();
        Log.i(LOG_TAG, "libSDL: FFPlayerView.onResume(): mRenderer.mGlSurfaceCreated "
                + mRender.mGlSurfaceCreated + " mRenderer.mPaused " + mRender.mPaused);
        if (mRender.mGlSurfaceCreated && !mRender.mPaused || Settings.NonBlockingSwapBuffers)
            mRender.nativeGlContextRecreated();
        if (mRender.accelerometer != null && mRender.accelerometer.openedBySDL) // For
                                                                                    // some
                                                                                    // reason
                                                                                    // it
                                                                                    // crashes
                                                                                    // here
                                                                                    // often
                                                                                    // -
                                                                                    // are
                                                                                    // we
                                                                                    // getting
                                                                                    // this
                                                                                    // event
                                                                                    // before
                                                                                    // initialization?
            mRender.accelerometer.start();
    };

    // This seems like redundant code - it handled in Activity.java
    @Override
    public boolean onKeyDown(int keyCode, final KeyEvent event) {
        Log.d(LOG_TAG, "Got key down event, id " + keyCode + " meta " + event.getMetaState()
                + " event " + event.toString());

        if (nativeKey(keyCode, 1) == 0)
            return super.onKeyDown(keyCode, event);
        return true;
    }

    @Override
    public boolean onKeyUp(int keyCode, final KeyEvent event) {
        // System.out.println("Got key up event, id " + keyCode + " meta " +
        // event.getMetaState());
        if (nativeKey(keyCode, 0) == 0)
            return super.onKeyUp(keyCode, event);
        return true;
    }

    public static native void nativeMotionEvent(int x, int y, int action, int pointerId,
            int pressure, int radius);

    public static native int nativeKey(int keyCode, int down);
    public static native int nativeGetDuration();
    public static native int nativeGetCurrentPosition();

    public static native void nativeTouchpad(int x, int y, int down, int multitouch);

    public static native void initJavaCallbacks();

    public static native void nativeHardwareMouseDetected(int detected);

    public static native void nativeMouseButtonsPressed(int buttonId, int pressedState);

    public static native void nativeMouseWheel(int scrollX, int scrollY);

    public static native void nativeGamepadAnalogJoystickInput(float stick1x, float stick1y,
            float stick2x, float stick2y, float rtrigger, float ltrigger);

    public interface ScreenKeyboardHelper {
        void showScreenKeyboardWithoutTextInputField();

        void showScreenKeyboard(final String oldText, boolean sendBackspace);

        void hideScreenKeyboard();

        boolean isScreenKeyboardShown();

        void setScreenKeyboardHintMessage(String s);
    }

    public interface AdHelper {
        void setAdvertisementVisible(final int visible);

        void getAdvertisementParams(int params[]);

        void requestNewAdvertisement();

        void setAdvertisementPosition(int x, int y);
    }

    public interface AppHelper {
        void LoadApplicationLibrary(final Context context);

        int getApplicationVersion();
    }

}
