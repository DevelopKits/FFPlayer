// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under project/java dir
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.ffmpeg.ffplayer.render;


import javax.microedition.khronos.egl.EGL11;

import org.ffmpeg.ffplayer.config.Globals;
import org.ffmpeg.ffplayer.render.SDLInput.DifferentTouchInput;

import android.content.Context;
import android.os.Bundle;
import android.view.MotionEvent;
import android.view.KeyEvent;
import android.view.InputDevice;
import android.view.Window;
import android.view.WindowManager;


import android.content.res.Resources;
import android.content.res.AssetManager;

import java.util.concurrent.locks.ReentrantLock;

import android.os.Build;
import java.lang.reflect.Method;
import java.util.LinkedList;

import java.nio.ByteOrder;
import android.content.Context;
import android.content.res.Resources;
import android.net.Uri;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.widget.MediaController;
import android.widget.MediaController.MediaPlayerControl;
import android.util.Log;

import java.util.Map;

import org.ffmpeg.ffplayer.R;

/**
 * Displays a video file. The FFPlayerView class can load images from various
 * sources (such as resources or content providers), takes care of computing its
 * measurement from the video so that it can be used in any layout manager, and
 * provides various display options such as scaling and tinting.
 */

public class FFPlayerView extends GLSurfaceView_SDL implements
		MediaPlayerControl {
	private static final String LOG_TAG = "FFPlayerView";
	private MediaController mMediaController;
	// all possible internal states
	private static final int STATE_ERROR = -1;
	private static final int STATE_IDLE = 0;
	private static final int STATE_PREPARING = 1;
	private static final int STATE_PREPARED = 2;
	private static final int STATE_PLAYING = 3;
	private static final int STATE_PAUSED = 4;
	private static final int STATE_PLAYBACK_COMPLETED = 5;

	// mCurrentState is a VideoView object's current state.
	// mTargetState is the state that a method caller intends to reach.
	// For instance, regardless the VideoView object's current state,
	// calling pause() intends to bring the object to a target state
	// of STATE_PAUSED.
	private int mCurrentState = STATE_IDLE;
	private int mTargetState = STATE_IDLE;

	public FFPlayerView(Context context, ScreenKeyboardHelper keyboardHelper,
			AdHelper adHelper, AppHelper appHelper) {
		super(context);
		mContext = context;
		touchInput = DifferentTouchInput.getInstance();
		setEGLConfigChooser(Globals.VideoDepthBpp, Globals.NeedDepthBuffer,
				Globals.NeedStencilBuffer, Globals.NeedGles2);
		mRenderer = new DefaultRender(context, keyboardHelper, adHelper,
				appHelper);
		setRenderer(mRenderer);
	}

	public void setMediaController(MediaController controller) {
		if (mMediaController != null) {
			mMediaController.hide();
		}
		mMediaController = controller;
		attachMediaController();
	}

	public void setMediaURI(Uri uri) {
		if (null == uri) {
			return;
		}
		String scheme = uri.getScheme();
		if (scheme == null || scheme.equals("file")) {
			// setDataSource(uri.getPath());
			return;
		}
	}

	public void setMediaURI(Uri uri, Map<String, String> headers) {
		if (null == headers) {
			setMediaURI(uri);
		}
	}

	private boolean isInPlaybackState() {
		return (mCurrentState != STATE_ERROR && mCurrentState != STATE_IDLE && mCurrentState != STATE_PREPARING);
	}

	private void attachMediaController() {
                Log.d(LOG_TAG, "attachMediaController in mMediaPlayer " + mMediaController);
		if (/* mMediaPlayer != null && */mMediaController != null) {
			mMediaController.setMediaPlayer(this);
			View anchorView = this.getParent() instanceof View ? (View) this
					.getParent() : this;
			mMediaController.setAnchorView(anchorView);
			mMediaController.setEnabled(isInPlaybackState());
                        Log.d(LOG_TAG, "start to show MediaController");
                        // TODO: debug this MediaController widget
			// mMediaController.show();
		}
	}

	// interface MediaPlayerControl start
	public boolean canPause() {
		// TODO: refine this
		return true;
	}

	public boolean canSeekBackward() {
		// TODO: refine this
		return true;
	}

	public boolean canSeekForward() {
		// TODO: refine this
		return true;
	}

	public int getBufferPercentage() {
		// TODO: add MediaPlayer.OnBufferingUpdateListener support
		return 0;
	}

	public int getCurrentPosition() {
		// TODO: refine this
		return 0;
	}

	public int getDuration() {
		// TODO: refine this
		return 0;
	}

	public boolean isPlaying() {
		return isInPlaybackState();
	}

	public void pause() {
		if (isInPlaybackState()) {
			// TODO: implement this
			mCurrentState = STATE_PAUSED;
		}
		mTargetState = STATE_PAUSED;
	}

	public void seekTo(int msec) {
		// TODO: implement this
		if (isInPlaybackState()) {
		} else {

			// mSeekWhenPrepared = msec;
		}
	}

	public void start() {
		if (isInPlaybackState()) {
			// TODO: implement this
		}
		mTargetState = STATE_PLAYING;
	}

	// interface MediaPlayerControl end

	@Override
	public boolean onTouchEvent(final MotionEvent event) {
		touchInput.process(event);
		if (DefaultRender.mRatelimitTouchEvents) {
			limitEventRate(event);
		}
		return true;
	};

	@Override
	public boolean onGenericMotionEvent(final MotionEvent event) {
		touchInput.processGenericEvent(event);
		if (DefaultRender.mRatelimitTouchEvents) {
			limitEventRate(event);
		}
		return true;
	}

	public void limitEventRate(final MotionEvent event) {
		// Wait a bit, and try to synchronize to app framerate, or event thread
		// will eat all CPU and we'll lose FPS
		// With Froyo the rate of touch events seems to be limited by OS, but
		// they are arriving faster then we're redrawing anyway
		if ((event.getAction() == MotionEvent.ACTION_MOVE || event.getAction() == MotionEvent.ACTION_HOVER_MOVE)) {
			synchronized (mRenderer) {
				try {
					mRenderer.wait(300L); // And sometimes the app decides not
											// to render at all, so this timeout
											// should not be big.
				} catch (InterruptedException e) {
				}
			}
		}
	}

	public void exitApp() {
		((DefaultRender) mRenderer).exitApp();
	};

	@Override
	public void onPause() {
		if (mRenderer.getState() == GLSurfaceView_SDL.Renderer.STATE_PAUSED)
			return;
		mRenderer.setState(GLSurfaceView_SDL.Renderer.STATE_PAUSED);
		((DefaultRender) mRenderer).nativeGlContextLostAsyncEvent();
		if (mRenderer.accelerometer != null) // For some reason it crashes here
												// often - are we getting this
												// event before initialization?
			mRenderer.accelerometer.stop();
		super.onPause();
	};

	public boolean isPaused() {
		return mRenderer.mPaused;
	}

	@Override
	public void onResume() {
		if (mRenderer.getState() != GLSurfaceView_SDL.Renderer.STATE_PAUSED)
			return;
		mRenderer.setState(GLSurfaceView_SDL.Renderer.STATE_ACTIVE);
		super.onResume();
		Log.i(LOG_TAG,
				"libSDL: FFPlayerView.onResume(): mRenderer.mGlSurfaceCreated "
						+ mRenderer.mGlSurfaceCreated + " mRenderer.mPaused "
						+ mRenderer.mPaused);
		if (mRenderer.mGlSurfaceCreated && !mRenderer.mPaused
				|| Globals.NonBlockingSwapBuffers)
			mRenderer.nativeGlContextRecreated();
		if (mRenderer.accelerometer != null
				&& mRenderer.accelerometer.openedBySDL) // For some reason it
														// crashes here often -
														// are we getting this
														// event before
														// initialization?
			mRenderer.accelerometer.start();
	};

	// This seems like redundant code - it handled in Activity.java
	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event) {
		// System.out.println("Got key down event, id " + keyCode + " meta " +
		// event.getMetaState() + " event " + event.toString());
		if (nativeKey(keyCode, 1) == 0)
			return super.onKeyDown(keyCode, event);
		return true;
	}

	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event) {
		// System.out.println("Got key up event, id " + keyCode + " meta " +
		// event.getMetaState());
		if (nativeKey(keyCode, 0) == 0)
			return super.onKeyUp(keyCode, event);
		return true;
	}

	DefaultRender mRenderer;
	Context mContext;
	DifferentTouchInput touchInput = null;

	public static native void nativeMotionEvent(int x, int y, int action,
			int pointerId, int pressure, int radius);

	public static native int nativeKey(int keyCode, int down);

	public static native void nativeTouchpad(int x, int y, int down,
			int multitouch);

	public static native void initJavaCallbacks();

	public static native void nativeHardwareMouseDetected(int detected);

	public static native void nativeMouseButtonsPressed(int buttonId,
			int pressedState);

	public static native void nativeMouseWheel(int scrollX, int scrollY);

	public static native void nativeGamepadAnalogJoystickInput(float stick1x,
			float stick1y, float stick2x, float stick2y, float rtrigger,
			float ltrigger);

	public interface ScreenKeyboardHelper {
		void showScreenKeyboardWithoutTextInputField();

		void showScreenKeyboard(final String oldText, boolean sendBackspace);

		void hideScreenKeyboard();

		boolean isScreenKeyboardShown();

		void setScreenKeyboardHintMessage(String s);
	}

	public interface AdHelper {
		void setAdvertisementVisible(final int visible);

		void getAdvertisementParams(int params[]);

		void requestNewAdvertisement();

		void setAdvertisementPosition(int x, int y);
	}

	public interface AppHelper {
		void LoadApplicationLibrary(final Context context);

		int getApplicationVersion();
	}

}
